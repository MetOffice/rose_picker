#!/usr/bin/env python
##############################################################################
# (C) British Crown Copyright 2018 Met Office.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Rose. If not, see <http://www.gnu.org/licenses/>.
##############################################################################
"""
Rose Picker program script. Execution starts here.
"""
from argparse import ArgumentParser, Namespace
import collections
import json
import os.path
from pathlib import Path
import re
from typing import Dict, List, Sequence

import rose_lfric
from rose_lfric.config import ConfigSyntaxError
from rose_lfric.config_tree import ConfigTree, ConfigTreeLoader

_NAMELISTS_REGEX = re.compile(r'^\s*namelist\s*:\s*(\w*)\s*(?:=\s*(\S+))?')


class RosePickerException(Exception):
    """
    Thrown by Rose Picker to indicate errors.
    """
    pass  # pylint: disable=unnecessary-pass


def _load_configuration(filename: Path,
                        include_dirs: Sequence[Path]) -> ConfigTree:
    """
    Load and expand the configuration file.
    """
    if not filename.exists():
        raise RosePickerException(f"File {filename} does not exist.")
    try:
        config_node = rose_lfric.config.load(str(filename))
        tree_loader = ConfigTreeLoader()

        tree_loader.load(filename.parent,
                         filename.name,
                         conf_dir_paths=include_dirs,
                         conf_node=config_node)
        return config_node
    except ConfigSyntaxError:
        raise RosePickerException(f"File {filename} is not a valid rose meta"
                                  " configuration file.")


def _list_configuration(config_node: ConfigTree) -> List[str]:
    """
    Get keys list of all the namelists/members in the configuration file.
    """
    node_keys = list(filter(_NAMELISTS_REGEX.match,
                            config_node.get_value().keys()))
    node_keys.sort()
    return node_keys


def _extract_namelists(config_node: ConfigTree,
                       required_properties: Sequence[str],
                       listnames: List[str],
                       namelist_config: Dict[str, Dict[str, Dict[str, str]]]):
    """
    Extracts namelist properties from meta-data.
    """
    node_keys = _list_configuration(config_node)
    for key in node_keys:

        match = _NAMELISTS_REGEX.match(key)
        node = match.group(0)
        namelist = match.group(1)
        member = match.group(2)

        if namelist:
            if not member:  # pylint: disable=no-else-continue
                listnames.append(namelist)
                namelist_config[namelist] = {}
                continue

            elif namelist not in namelist_config.keys():
                message = (
                    'namelist:' + namelist
                    + ' has no section in metadata configuration file')
                raise RosePickerException(message)

            else:
                namelist_config[namelist][member] = {}

                member_node = config_node.get([node])
                member_node_keys = member_node.get_value().keys()
                for i in required_properties:
                    if i in member_node_keys:
                        member_prop = member_node.get([i])
                        member_prop = member_prop.get_value()
                        namelist_config[namelist][member][i] \
                            = member_prop


def main(meta_filename: Path, include_dirs: Sequence[Path], output_dir: Path):
    """
    Rose Picker entry point.

    Load in a config file. This is using Rose's "config.py" code which is
    different to pythons ConfigParser. We need to use config.py to ensure any
    changes to the way rose meta data is treated are picked up.

    Rose's "config_tree.py" code is used to expand any import statements in the
    specified configuration file.
    """
    config_node = _load_configuration(meta_filename, include_dirs)

    required_properties = ['bounds',
                           'enumeration',
                           'expression',
                           'kind',
                           'length',
                           'string_length',
                           'type',
                           'values']
    listnames: List[str] = []
    namelist_config = collections.OrderedDict()
    _extract_namelists(config_node, required_properties,
                       listnames, namelist_config)

    basename = os.path.basename(meta_filename).split('.')

    # Output as .json file
    nml_config_filename = '{}.json'.format(basename[0])
    output = open('{}/{}'.format(
        output_dir, nml_config_filename), 'wt')
    json.dump(namelist_config, output, indent=4, ensure_ascii=True)
    output.close()

    # Write out namelists in configuration
    output = open('{}/config_namelists.txt'.format(output_dir), 'wt')

    for listname in listnames:
        output.write('{}\n'.format(listname))

    output.close()


def _cli() -> Namespace:
    parser = ArgumentParser(add_help=False, description=__doc__)
    parser.add_argument('-help', '-h', '--help', action='help',
                        help='Show this help message and exit')
    parser.add_argument('-directory', metavar='path',
                        type=Path, default=Path.cwd(),
                        help='Generated source files are put here.')
    parser.add_argument('-include_dirs', action='append',
                        type=Path,
                        help='Include directory to list of directories '
                             'to search for inherited metadata files')
    parser.add_argument('meta_filename', metavar='description-file',
                        type=Path,
                        help='The metadata file to load')
    return parser.parse_args()

if __name__ == '__main__':
    ARGS = _cli()
    main(ARGS.meta_filename, ARGS.include_dirs, ARGS.directory)
